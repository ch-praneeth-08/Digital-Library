// controllers/materialController.js
const Material = require('../models/Material');
const aqp = require('api-query-params'); // Import the library
const path = require('path');
const fs = require('fs');

/**
 * Helper function to parse comma-separated strings or arrays into trimmed arrays.
 * @param {*} input The input value (string or array).
 * @returns {string[]} An array of trimmed strings, or an empty array.
 */
const parseToArray = (input) => {
    if (!input) return [];
    if (Array.isArray(input)) {
        return input.map(item => typeof item === 'string' ? item.trim() : item)
                    .filter(item => item != null && item !== ''); // Handle potential null/empty strings and trim
    }
    if (typeof input === 'string') {
        return input.split(',')
                    .map(item => item.trim())
                    .filter(Boolean); // Handle comma-separated string
    }
    return []; // Return empty array for other types
}


// @desc    Upload a new academic material
// @route   POST /api/materials/upload
// @access  Private (e.g., Faculty, Admin - controlled by route middleware)
const uploadMaterial = async (req, res) => {
    // Metadata is in req.body
    // File info is in req.file (from multer)
    // User info is in req.user (from protect middleware)
    const {
        title, authors, publicationYear, materialType,
        keywords, category, description,
      } = req.body;

    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded. Please include a file named "materialFile".' });
    }

    try {
      // Prepare data for Mongoose model, ensuring types are correct
      const materialData = {
        title,
        authors: parseToArray(authors), // Parse authors
        publicationYear: publicationYear ? Number(publicationYear) : undefined, // Convert year to number
        materialType,
        // Parse keywords and convert to lowercase (consistent storage)
        keywords: parseToArray(keywords).map(k => k.toLowerCase()),
        category: category ? category.trim() : undefined, // Ensure category is trimmed (though schema also trims)
        description: description ? description.trim() : undefined,
        uploadedBy: req.user._id, // Get user ID from authenticated user
        fileName: req.file.originalname, // Original name of the file
        filePath: req.file.filename, // Unique name generated by Multer
        fileMimeType: req.file.mimetype,
      };

      // Create and save the material document in MongoDB
      const material = await Material.create(materialData);

      // Respond successfully
      res.status(201).json({
        message: 'Material uploaded successfully!',
        material: { // Send back basic details of the created material
           _id: material._id,
           title: material.title,
           filePath: material.filePath,
           uploadedAt: material.createdAt,
        }
      });

    } catch (error) {
      // Handle errors during database operation or validation
      console.error("Material Upload Controller Error:", error);
      if (error.name === 'ValidationError') {
           // Handle Mongoose validation errors (e.g., missing required field, enum mismatch)
           return res.status(400).json({ message: `Validation Error: ${error.message}` });
      }
      // Handle generic server errors
      res.status(500).json({ message: 'Server error during material upload.' });
    }
};


// @desc    Get all/filtered academic materials with pagination (using api-query-params) - CORRECTED REGEX & DEBUG LOGS
// @route   GET /api/materials
// @access  Public (as configured in routes)
const getMaterials = async (req, res) => {
    console.log('\n--- [DEBUG] GET /api/materials Route Hit ---'); // Log start
    try {
        // --- Log Raw Query Parameters ---
        console.log('[DEBUG] Received Raw Query Params:', req.query);

        // --- Use api-query-params ---
        const { filter: aqpFilter, skip, limit, sort, projection } = aqp(req.query, {
             // *** FIX 1: Add keyword to blacklist ***
             blacklist: ['keyword'], // Prevent aqp from adding a 'keyword' field filter automatically
             casters: {
                  insensitive: val => ({ $regex: `^${val}$`, $options: 'i' })
             },
             castParams: {
                  category: 'insensitive',
             },
             // whitelist: [...]
        });

        // Initialize the final filter object - Clone aqpFilter
        let finalFilter = { ...aqpFilter };
        console.log('[DEBUG] Filter object AFTER api-query-params processing (should NOT contain keyword):', JSON.stringify(finalFilter, null, 2));


        // --- **REGEX** Search Handling for 'keyword' Parameter ---
        if (req.query.keyword) {
            const searchKeyword = req.query.keyword;
            console.log(`[DEBUG] Keyword parameter detected: "${searchKeyword}"`);

            // Escape special regex characters
            const escapedKeyword = searchKeyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            const regex = new RegExp(escapedKeyword, 'i'); // 'i' for case-insensitive
            console.log(`[DEBUG] Regex created: ${regex}`);

            // *** FIX 2: Correctly assign the regex variable ***
            const regexConditions = {
                $or: [
                    { title: regex },       // Use the regex variable here
                    { description: regex }, // Use the regex variable here
                    { keywords: regex },    // Use the regex variable here (checks array elements)
                    { authors: regex },     // Use the regex variable here (checks array elements)
                    { category: regex }     // Use the regex variable here
                ]
            };
            console.log('[DEBUG] Regex $or conditions prepared:', JSON.stringify(regexConditions, null, 2));


            // Combine with existing filters from AQP (if any)
            const aqpHasFilters = Object.keys(aqpFilter).length > 0;

            if (aqpHasFilters) {
                 console.log('[DEBUG] Combining AQP filters with Regex search using $and.');
                 // Since aqpFilter is clean (no 'keyword'), combine safely
                 finalFilter = { // Create new finalFilter with $and
                      $and: [
                           aqpFilter,       // Add original filters from AQP
                           regexConditions // Add our $or block for regex search
                      ]
                 };
            } else {
                 console.log('[DEBUG] No other AQP filters found, using only Regex search conditions.');
                 // If AQP didn't produce any filters, the main filter becomes just the regex search
                 finalFilter = regexConditions; // Overwrite finalFilter
            }

        } else {
             console.log('[DEBUG] No keyword parameter detected.');
        }
        // --- End Regex Search Handling ---


        // --- Log Final Filter Object Before DB Query ---
        console.log('>>> [DEBUG] FINAL Filter Object Sent to MongoDB:', JSON.stringify(finalFilter, null, 2));


        // --- Apply Defaults ---
        const finalLimit = limit && limit > 0 ? limit : 10;
        const finalSkip = skip >= 0 ? skip : 0;
        console.log(`[DEBUG] Pagination: finalSkip=${finalSkip}, finalLimit=${finalLimit}`);
        console.log(`[DEBUG] Sorting:`, sort || '(default)');
        console.log(`[DEBUG] Projection:`, projection || '(default)');

        // --- Execute Count Query ---
        console.log('[DEBUG] Executing countDocuments query...');
        const totalMaterials = await Material.countDocuments(finalFilter); // Use the final combined filter
        console.log(`<<< [DEBUG] countDocuments Result: ${totalMaterials}`);

        // --- Execute Find Query ---
        console.log('[DEBUG] Executing find query...');
        const materialsQuery = Material.find(finalFilter) // Use the final combined filter
          .sort(sort)
          .skip(finalSkip)
          .limit(finalLimit)
          .select(projection);

        const materials = await materialsQuery;
        console.log(`<<< [DEBUG] find Query Result Length (current page): ${materials.length}`);


        // --- Calculate Pagination Details ---
        const totalPages = Math.ceil(totalMaterials / finalLimit);
        const currentPage = Math.floor(finalSkip / finalLimit) + 1;
        const pagination = {
            currentPage: currentPage, totalPages: totalPages, totalItems: totalMaterials,
            itemsPerPage: finalLimit, nextPage: (currentPage < totalPages) ? currentPage + 1 : null,
            prevPage: currentPage > 1 ? currentPage - 1 : null
        };
        console.log('[DEBUG] Calculated Pagination:', pagination);


        // --- Send Successful Response ---
        const responseJson = {
            success: true, count: materials.length, pagination: pagination, data: materials,
        };
        console.log('--- [DEBUG] Sending success response. ---');
        res.status(200).json(responseJson);

    } catch (error) {
        // --- Log Errors ---
        console.error("!!! [DEBUG] ERROR in getMaterials:", error); // Log the full error
        res.status(500).json({ success: false, message: "Server error retrieving materials." });
    }
};


// @desc    Delete a material
// @route   DELETE /api/materials/:id
// @access  Private (Admin or Owner - controlled by route middleware AND controller logic)
const deleteMaterial = async (req, res) => {
    try {
        const materialId = req.params.id;
        const loggedInUser = req.user; // Assumes protect middleware adds user info

        // 1. Find the material by ID
        const material = await Material.findById(materialId);

        // 2. Check if material exists
        if (!material) {
            return res.status(404).json({ success: false, message: 'Material not found' });
        }

        // 3. Authorization Check: Admin OR Owner
        const isAdmin = loggedInUser.role === 'admin';
        const isOwner = material.uploadedBy.toString() === loggedInUser._id.toString();

        if (!isAdmin && !isOwner) {
            return res.status(403).json({
                success: false,
                message: 'User not authorized to delete this material',
            });
        }

        // 4. Get file path before deleting DB record
        // Ensure 'uploads' directory is correctly referenced relative to the project root
        const filePathOnDisk = path.join(__dirname, '..', 'uploads', material.filePath);
        console.log(`[DEBUG] Attempting to delete file at path: ${filePathOnDisk}`);


        // 5. Delete the database record AND capture the deleted document
        const deletedMaterial = await Material.findByIdAndDelete(materialId);

        if (!deletedMaterial) {
            // Should not happen if findById worked, but handle just in case
            console.log(`[DEBUG] Material with ID ${materialId} not found during delete operation.`);
            return res.status(404).json({ success: false, message: 'Material not found during delete operation.' });
        }
        console.log(`[DEBUG] Successfully deleted material record with ID: ${materialId}`);


        // 6. Delete the physical file (asynchronously, errors are logged but don't block response)
        fs.unlink(filePathOnDisk, (err) => {
            if (err) {
                // Log error, but don't send error response as DB record is deleted
                console.error(`!!! [DEBUG] Error deleting file ${filePathOnDisk}:`, err);
                // Common reasons: Incorrect path, file doesn't exist, permissions issue.
            } else {
                console.log(`[DEBUG] Successfully deleted physical file: ${filePathOnDisk}`);
            }
        });

        // 7. Send success response with deleted data
        res.status(200).json({
            success: true,
            message: 'Material deleted successfully',
            data: deletedMaterial // Return the data of the deleted document
        });

    } catch (error) {
        console.error("!!! [DEBUG] Delete Material Error:", error);
        if (error.name === 'CastError') {
            return res.status(400).json({ success: false, message: `Invalid material ID format: ${req.params.id}` });
        }
        res.status(500).json({ success: false, message: 'Server error during material deletion.' });
    }
};


// --- Export all controller functions ---
module.exports = {
    uploadMaterial,
    getMaterials, // Ensure this points to the function with fixes & debug logs
    deleteMaterial,
};