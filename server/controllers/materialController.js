// controllers/materialController.js
const Material = require('../models/Material');
const aqp = require('api-query-params'); // Import the library
const path = require('path');
const fs = require('fs');

/**
 * Helper function to parse comma-separated strings or arrays into trimmed arrays.
 * @param {*} input The input value (string or array).
 * @returns {string[]} An array of trimmed strings, or an empty array.
 */
const parseToArray = (input) => {
    if (!input) return [];
    if (Array.isArray(input)) {
        return input.map(item => typeof item === 'string' ? item.trim() : item)
                    .filter(item => item != null && item !== ''); // Handle potential null/empty strings and trim
    }
    if (typeof input === 'string') {
        return input.split(',')
                    .map(item => item.trim())
                    .filter(Boolean); // Handle comma-separated string
    }
    return []; // Return empty array for other types
}


// @desc    Upload a new academic material
// @route   POST /api/materials/upload
// @access  Private (e.g., Faculty, Admin - controlled by route middleware)
const uploadMaterial = async (req, res) => {
    // Metadata is in req.body
    // File info is in req.file (from multer)
    // User info is in req.user (from protect middleware)
    const {
        title, authors, publicationYear, materialType,
        keywords, category, description,
      } = req.body;

    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded. Please include a file named "materialFile".' });
    }

    try {
      // Prepare data for Mongoose model, ensuring types are correct
      const materialData = {
        title,
        authors: parseToArray(authors), // Parse authors
        publicationYear: publicationYear ? Number(publicationYear) : undefined, // Convert year to number
        materialType,
        // Parse keywords and convert to lowercase (consistent storage)
        keywords: parseToArray(keywords).map(k => k.toLowerCase()),
        category: category ? category.trim() : undefined, // Ensure category is trimmed (though schema also trims)
        description: description ? description.trim() : undefined,
        uploadedBy: req.user._id, // Get user ID from authenticated user
        fileName: req.file.originalname, // Original name of the file
        filePath: req.file.filename, // Unique name generated by Multer
        fileMimeType: req.file.mimetype,
      };

      // Create and save the material document in MongoDB
      const material = await Material.create(materialData);

      // Respond successfully
      res.status(201).json({
        message: 'Material uploaded successfully!',
        material: { // Send back basic details of the created material
           _id: material._id,
           title: material.title,
           filePath: material.filePath,
           uploadedAt: material.createdAt,
        }
      });

    } catch (error) {
      // Handle errors during database operation or validation
      console.error("Material Upload Controller Error:", error);
      if (error.name === 'ValidationError') {
           // Handle Mongoose validation errors (e.g., missing required field, enum mismatch)
           return res.status(400).json({ message: `Validation Error: ${error.message}` });
      }
      // Handle generic server errors
      res.status(500).json({ message: 'Server error during material upload.' });
    }
};


// @desc    Get all/filtered academic materials with pagination (using api-query-params)
// @route   GET /api/materials
// @access  Public (as configured in routes)
const getMaterials = async (req, res) => {
    try {
        // --- Use api-query-params to parse the query string for filters, sort, etc. ---
        // Exclude 'keyword' from automatic AQP processing if we handle it manually
        const { filter, skip, limit, sort, projection } = aqp(req.query, {
             // blacklist: ['keyword'], // Option 1: Exclude keyword from AQP filter
             casters: {
                  insensitive: val => ({ $regex: `^${val}$`, $options: 'i' }) // Keep for other filters like category
             },
             castParams: {
                  category: 'insensitive',
                  // title: 'insensitive', // Example if you wanted exact match insensitive title filter
             },
             // whitelist: [...] // Optional: whitelist allowed AQP fields
        });

        // --- **REGEX** Search Handling for 'keyword' Parameter ---
        // Manually handle the 'keyword' parameter using $regex
        if (req.query.keyword) {
            const searchKeyword = req.query.keyword;
            console.log("Using Regex search for parameter 'keyword':", searchKeyword);

            // Escape special regex characters in user input
            const escapedKeyword = searchKeyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            const regex = new RegExp(escapedKeyword, 'i'); // 'i' for case-insensitive

            // If other filters exist from AQP, combine them with the $or condition for regex search
            // This creates a structure like: { $and: [ { other_aqp_filters }, { $or: [ regex_conditions ] } ] }
            // If no other filters exist, just use the $or condition directly.

            const regexConditions = {
                $or: [
                    { title: regex },
                    { description: regex },
                    { keywords: regex }, // Check if any element in the keywords array matches
                    { authors: regex },  // Check if any element in the authors array matches
                    { category: regex }  // Check the category field
                ]
            };

            // Check if AQP produced any filters (besides potentially 'keyword' itself)
            const aqpHasFilters = Object.keys(filter).length > 0;

            if (aqpHasFilters) {
                 // Combine existing AQP filters with our regex search using $and
                 // This handles cases like ?category=Physics&keyword=thermo
                 filter.$and = filter.$and || []; // Initialize $and if it doesn't exist
                 filter.$and.push(regexConditions); // Add our $or block for regex search

                 // Optional: Remove 'keyword' field if AQP added it automatically based on query param
                 // delete filter.keyword; // Uncomment if 'keyword' field appears in 'filter' unexpectedly
            } else {
                 // If AQP didn't produce any filters, the main filter becomes just the regex search
                 Object.assign(filter, regexConditions); // Copy the $or conditions into the filter
            }
        }
        // --- End Regex Search Handling ---


        // --- Log Parsed Parameters (for debugging) ---
        console.log("Filter Query Sent to MongoDB:", JSON.stringify(filter, null, 2));
        console.log("Skip:", skip);
        console.log("Limit (from AQP):", limit);
        console.log("Sort:", sort);
        console.log("Projection:", projection);

        // --- Apply Defaults (especially for limit/skip if not provided) ---
        const finalLimit = limit && limit > 0 ? limit : 10; // Default limit: 10 items
        const finalSkip = skip >= 0 ? skip : 0; // Default skip: 0

        console.log("Final Skip:", finalSkip);
        console.log("Final Limit:", finalLimit);

        // --- Execute Query ---
        const materialsQuery = Material.find(filter) // Use the potentially modified filter object
          .sort(sort)
          .skip(finalSkip)
          .limit(finalLimit)
          .select(projection);

        // Execute the actual database query
        const materials = await materialsQuery;
        console.log(`Found ${materials.length} materials for the current page.`);

        // --- Get Total Count for Pagination ---
        // Use the same filter object for counting total matching documents
        const totalMaterials = await Material.countDocuments(filter);
        console.log(`Total matching materials (before pagination): ${totalMaterials}`);

        // --- Calculate Pagination Details ---
        const totalPages = Math.ceil(totalMaterials / finalLimit);
        const currentPage = Math.floor(finalSkip / finalLimit) + 1;

        const pagination = {
            currentPage: currentPage,
            totalPages: totalPages,
            totalItems: totalMaterials,
            itemsPerPage: finalLimit,
            nextPage: (currentPage < totalPages) ? currentPage + 1 : null,
            prevPage: currentPage > 1 ? currentPage - 1 : null
        };
        console.log("Pagination results:", pagination);

        // --- Send Successful Response ---
        res.status(200).json({
            success: true,
            count: materials.length, // Number of items on this page
            pagination: pagination,
            data: materials, // Array of materials found for this page
        });

    } catch (error) {
        console.error("Get Materials Error (using Regex):", error);
        res.status(500).json({ success: false, message: "Server error retrieving materials." });
    }
};


// @desc    Delete a material
// @route   DELETE /api/materials/:id
// @access  Private (Admin or Owner - controlled by route middleware AND controller logic)
const deleteMaterial = async (req, res) => {
    try {
        const materialId = req.params.id;
        const loggedInUser = req.user; // Assumes protect middleware adds user info

        // 1. Find the material by ID
        const material = await Material.findById(materialId);

        // 2. Check if material exists
        if (!material) {
            return res.status(404).json({ success: false, message: 'Material not found' });
        }

        // 3. Authorization Check: Admin OR Owner
        const isAdmin = loggedInUser.role === 'admin';
        const isOwner = material.uploadedBy.toString() === loggedInUser._id.toString();

        if (!isAdmin && !isOwner) {
            return res.status(403).json({
                success: false,
                message: 'User not authorized to delete this material',
            });
        }

        // 4. Get file path before deleting DB record
        const filePathOnDisk = path.join(__dirname, '..', 'uploads', material.filePath); // Construct full path

        // 5. Delete the database record AND capture the deleted document
        const deletedMaterial = await Material.findByIdAndDelete(materialId);

        if (!deletedMaterial) {
            // Should not happen if findById worked, but handle just in case
            return res.status(404).json({ success: false, message: 'Material not found during delete operation.' });
        }

        // 6. Delete the physical file (asynchronously, errors are logged but don't block response)
        fs.unlink(filePathOnDisk, (err) => {
            if (err) {
                // Log error, but don't send error response as DB record is deleted
                console.error(`Error deleting file ${filePathOnDisk}:`, err);
            } else {
                console.log(`Successfully deleted file: ${filePathOnDisk}`);
            }
        });

        // 7. Send success response with deleted data
        res.status(200).json({
            success: true,
            message: 'Material deleted successfully',
            data: deletedMaterial // Return the data of the deleted document
        });

    } catch (error) {
        console.error("Delete Material Error:", error);
        if (error.name === 'CastError') {
            return res.status(400).json({ success: false, message: `Invalid material ID format: ${req.params.id}` });
        }
        res.status(500).json({ success: false, message: 'Server error during material deletion.' });
    }
};


// --- Export all controller functions ---
module.exports = {
    uploadMaterial,
    getMaterials,
    deleteMaterial,
};