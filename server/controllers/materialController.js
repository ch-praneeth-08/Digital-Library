// controllers/materialController.js
const Material = require('../models/Material');
const aqp = require('api-query-params'); // Import the library
const path = require('path');
const fs = require('fs');
/**
 * Helper function to parse comma-separated strings or arrays into trimmed arrays.
 * @param {*} input The input value (string or array).
 * @returns {string[]} An array of trimmed strings, or an empty array.
 */
const parseToArray = (input) => {
    if (!input) return [];
    if (Array.isArray(input)) {
        return input.map(item => typeof item === 'string' ? item.trim() : item)
                    .filter(item => item != null && item !== ''); // Handle potential null/empty strings and trim
    }
    if (typeof input === 'string') {
        return input.split(',')
                    .map(item => item.trim())
                    .filter(Boolean); // Handle comma-separated string
    }
    return []; // Return empty array for other types
}


// @desc    Upload a new academic material
// @route   POST /api/materials/upload
// @access  Private (e.g., Faculty, Admin - controlled by route middleware)
const uploadMaterial = async (req, res) => {
    // Metadata is in req.body
    // File info is in req.file (from multer)
    // User info is in req.user (from protect middleware)
    const {
        title, authors, publicationYear, materialType,
        keywords, category, description,
      } = req.body;

    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded. Please include a file named "materialFile".' });
    }

    try {
      // Prepare data for Mongoose model, ensuring types are correct
      const materialData = {
        title,
        authors: parseToArray(authors), // Parse authors
        publicationYear: publicationYear ? Number(publicationYear) : undefined, // Convert year to number
        materialType,
        // Parse keywords and convert to lowercase (consistent storage)
        keywords: parseToArray(keywords).map(k => k.toLowerCase()),
        category: category ? category.trim() : undefined, // Ensure category is trimmed (though schema also trims)
        description: description ? description.trim() : undefined,
        uploadedBy: req.user._id, // Get user ID from authenticated user
        fileName: req.file.originalname, // Original name of the file
        filePath: req.file.filename, // Unique name generated by Multer
        fileMimeType: req.file.mimetype,
      };

      // Create and save the material document in MongoDB
      const material = await Material.create(materialData);

      // Respond successfully
      res.status(201).json({
        message: 'Material uploaded successfully!',
        material: { // Send back basic details of the created material
           _id: material._id,
           title: material.title,
           filePath: material.filePath,
           uploadedAt: material.createdAt,
        }
      });

    } catch (error) {
      // Handle errors during database operation or validation
      console.error("Material Upload Controller Error:", error);
      if (error.name === 'ValidationError') {
           // Handle Mongoose validation errors (e.g., missing required field, enum mismatch)
           return res.status(400).json({ message: `Validation Error: ${error.message}` });
      }
      // Handle generic server errors
      res.status(500).json({ message: 'Server error during material upload.' });
    }
};


// @desc    Get all/filtered academic materials with pagination (using api-query-params)
// @route   GET /api/materials
// @access  Public (as configured in routes)
const getMaterials = async (req, res) => {
    try {
        // --- Use api-query-params to parse the query string ---
        const { filter, skip, limit, sort, projection } = aqp(req.query, {
             // --- Options ---
             // Customize search key if you use 'keyword' instead of 'q' for text search param
             // searchKey: 'keyword',

             // Define casters for custom transformations
             casters: {
                  // Caster for case-insensitive full string matching using regex
                  insensitive: val => ({ $regex: `^${val}$`, $options: 'i' })
             },
             // Map query parameters to use the specific casters
             castParams: {
                  // Apply the 'insensitive' caster to the 'category' query parameter
                  category: 'insensitive',
                  // Add other fields for case-insensitive matching if needed:
                  // title: 'insensitive',
             },
             // Whitelisting is recommended for security if you know all allowed filter fields:
             // whitelist: ['title', 'authors', 'publicationYear', 'materialType', 'keywords', 'category']
        });

        // --- Manual Handling for Text Search with 'keyword' Parameter ---
        // If you didn't use `searchKey: 'keyword'` in aqp options,
        // and you want text search via the 'keyword' query parameter:
        if (req.query.keyword && !filter.$text) {
             // This assumes a text index exists on your Material model
             console.log("Manually adding $text search for parameter 'keyword':", req.query.keyword);
             filter.$text = { $search: req.query.keyword };
        }
        // --- End Manual Handling ---

        // --- Log Parsed Parameters (for debugging) ---
        console.log("Filter after AQP:", JSON.stringify(filter, null, 2));
        console.log("Skip:", skip);
        console.log("Limit (from AQP):", limit);
        console.log("Sort:", sort);
        console.log("Projection:", projection);

        // --- Apply Defaults (especially for limit/skip if not provided) ---
        // AQP provides the value if present, otherwise null/undefined. We set defaults.
        const finalLimit = limit && limit > 0 ? limit : 10; // Default limit: 10 items
        const finalSkip = skip >= 0 ? skip : 0; // Default skip: 0 (start from beginning)

        console.log("Final Skip:", finalSkip);
        console.log("Final Limit:", finalLimit);


        // --- Execute Query ---
        // Find materials based on the combined filter
        const materialsQuery = Material.find(filter)
          .sort(sort)            // Apply sorting object from aqp
          .skip(finalSkip)         // Apply calculated skip value
          .limit(finalLimit)      // Apply calculated limit value
          .select(projection);   // Apply field projection object from aqp

        // Optionally populate related data (e.g., the user who uploaded)
        // materialsQuery = materialsQuery.populate('uploadedBy', 'name email');

        // Execute the actual database query
        const materials = await materialsQuery;
        console.log(`Found ${materials.length} materials for the current page.`);


        // --- Get Total Count for Pagination ---
        // Perform a separate count query using the *same filter* but without skip/limit
        const totalMaterials = await Material.countDocuments(filter);
        console.log(`Total matching materials (before pagination): ${totalMaterials}`);


        // --- Calculate Pagination Details ---
        const totalPages = Math.ceil(totalMaterials / finalLimit);
        const currentPage = Math.floor(finalSkip / finalLimit) + 1; // Calculate current page

        const pagination = {
            currentPage: currentPage,
            totalPages: totalPages,
            totalItems: totalMaterials,
            itemsPerPage: finalLimit, // The actual limit used for the query
            nextPage: (currentPage < totalPages) ? currentPage + 1 : null,
            prevPage: currentPage > 1 ? currentPage - 1 : null
        };
        console.log("Pagination results:", pagination);

        // --- Send Successful Response ---
        res.status(200).json({
            success: true,
            count: materials.length, // Number of items returned on this page
            pagination: pagination,
            data: materials, // The array of material documents found
        });

    } catch (error) {
        // Handle any errors during query execution or processing
        console.error("Get Materials Error (using AQP):", error);
        res.status(500).json({ success: false, message: "Server error retrieving materials." });
    }
};

const deleteMaterial = async (req, res) => {
    try {
        const materialId = req.params.id;
        const loggedInUser = req.user;

        // 1. Find the material by ID (still needed for authorization check)
        const material = await Material.findById(materialId);

        // 2. Check if material exists
        if (!material) {
            return res.status(404).json({ success: false, message: 'Material not found' });
        }

        // 3. Authorization Check: Admin OR Owner
        const isAdmin = loggedInUser.role === 'admin';
        const isOwner = material.uploadedBy.toString() === loggedInUser._id.toString();

        if (!isAdmin && !isOwner) {
            return res.status(403).json({
                success: false,
                message: 'User not authorized to delete this material',
            });
        }

        // 4. Proceed with deletion - Get file path *before* deleting DB record
        const filePath = path.join(__dirname, '..', 'uploads', material.filePath);

        // 5. Delete the database record AND CAPTURE THE DELETED DOCUMENT
        const deletedMaterial = await Material.findByIdAndDelete(materialId); // <-- Capture result here

        // --- Check if deletion was successful (findByIdAndDelete returns null if not found) ---
        // This check is slightly redundant because we already found 'material' above,
        // but good practice if the 'findById' check was removed.
        if (!deletedMaterial) {
             // Should ideally not happen if the first findById worked, but handle anyway
            return res.status(404).json({ success: false, message: 'Material not found during delete operation.' });
        }
        // --- End Check ---

        // 6. Delete the physical file
        fs.unlink(filePath, (err) => {
            if (err) {
                console.error(`Error deleting file ${filePath}:`, err);
            } else {
                console.log(`Successfully deleted file: ${filePath}`);
            }
        });

        // 7. Send success response WITH THE DELETED DATA
        res.status(200).json({
            success: true,
            message: 'Material deleted successfully',
            data: deletedMaterial // <-- Return the deleted document here
        });

    } catch (error) {
        console.error("Delete Material Error:", error);
        if (error.name === 'CastError') {
            return res.status(400).json({ success: false, message: `Invalid material ID format: ${req.params.id}` });
        }
        res.status(500).json({ success: false, message: 'Server error during material deletion.' });
    }
};


// --- Export all controller functions ---
module.exports = {
    uploadMaterial,
    getMaterials,
    deleteMaterial, // Export the new function
};